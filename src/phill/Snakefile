import importlib.resources
import itertools
import os
from glob import iglob
from pathlib import Path
from socket import gethostname

import snek5000
from phill.output import OutputPhill as Output
from snek5000.util import now
from snek5000.util.archive import tar_name, archive, clean_simul


# Case name
CASE = "phill"
CONFIG = Output.get_configfile()
ROOT = Output.get_root()
NEK_SOURCE_ROOT = snek5000.source_root()

snek5000.ensure_env()

configfile: CONFIG

# Necessary to pass configuration to other Snakemake modules
config.update(
    {
        "CASE": CASE,
        "file": CONFIG,
        "includes": " ".join(Output().fortran_inc_flags),
        "objects" : " ".join(Output().makefile_usr_obj),
    }
)

if os.getenv("SNEK_DEBUG"):
    config["CFLAGS"] += " -O0 -g"
    config["FFLAGS"] += " -O0 -g -ffpe-trap=invalid,zero,overflow,underflow -Wall"


rule test:
    shell: 'echo $NEK_SOURCE_ROOT $PATH'


# default rule
rule all:
    input:
        'nek5000'

# shorthand for mesh
rule mesh:
    input: f"{CASE}.re2", f"{CASE}.ma2"

# compile
rule compile:
    input:
        f"{CASE}.usr",
        'makefile_usr.inc',
        'makefile',
        *iglob('toolbox/*'),
        *iglob('sgs/*'),
        nekconfig = NEK_SOURCE_ROOT + "/bin/nekconfig"
    output:
        NEK_SOURCE_ROOT + "/3rd_party/gslib/lib/libgs.a",
        f'{CASE}.f',
        exe='nek5000'
    shell:
        """
        {input.nekconfig} -build-dep
        make -j {output.exe}
        """

# run
rule run:
    input:
        f'{CASE}.re2',
        f'{CASE}.ma2',
        f'{CASE}.par',
        'SESSION.NAME',
        'nek5000'
    log:
        "logs/run_" + now() + ".log"
    params:
        nproc = str(os.cpu_count()),
        case = f"{CASE}"
    shell:
        """
        ln -sf {log} {params.case}.log
        echo "Log file: $PWD"/{params.case}.log
        {config[MPIEXEC]} -n {params.nproc} ./nek5000 > {log} &
        """

# on cluster
rule srun:
    input:
        f'{CASE}.re2',
        f'{CASE}.ma2',
        f'{CASE}.par',
        'SESSION.NAME',
        'nek5000'
    log:
        "logs/run_" + now() + ".log"
    params:
        nproc = str(os.cpu_count()),
        case = f"{CASE}"
    shell:
        """
        ln -sf {log} {params.case}.log
        echo "Log file: $PWD"/{params.case}.log
        {config[MPIEXEC]} -n {params.nproc} ./nek5000 | tee {log}
        """

# clean compiler output
rule clean:
    params:
        case = f'{CASE}',
    shell:
        """
        echo "cleaning Nek5000 ..."
        rm -fv {params.case}.f nek5000
        rm -rf obj
        rm -fv $NEK_SOURCE_ROOT/core/mpif.h
        """

# clean simulation files
rule cleansimul:
    params:
        case = f'{CASE}',
        tarball = tar_name(compress_format=".zst")
    run:
        clean_simul(params.case, params.tarball)

# clean everything
rule cleanall:
    shell:
        """
        snakemake clean cleansimul
        yes | nekconfig clean
        """

# create an archive with all of our results
rule archive:
    params:
        solution = sorted(
            itertools.chain.from_iterable(
                (
                    iglob(f'{prefix}{CASE}0.f*')
                    for prefix in ("", "vgr", "c2D", "sts")
                )
            )
        ),
        rest = [
            'SESSION.NAME',
            'params_simul.xml',
            'SIZE',
            *iglob(f'rs6{CASE}0.f*'),
            f'{CASE}.re2',
            f'{CASE}.ma2',
            f'{CASE}.par',
            f'{CASE}.usr',
        ],
        tarball = tar_name()
    run:
        archive(params.tarball, params.solution, remove=True)
        archive(params.tarball, params.rest)
        archive(params.tarball + ".zst", readonly=True)


# internal rules
# ==============
module internal:
    snakefile: snek5000.get_asset('internal.smk')
    config: config

use rule * from internal as internal_*
